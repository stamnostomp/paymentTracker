import { promises } from 'fs';
import path from 'path';
import * as postcss from 'postcss';
import allCols from 'color-name';
import * as CssWhat from 'css-what';
import deepEqual from 'deep-equal';
import tailwindcss from 'tailwindcss';
import resolveConfig from 'tailwindcss/resolveConfig.js';
import chalk from 'chalk';
import { isEmpty, isArray } from 'lodash';

function elmString(content) {
    return `"${content
        .replace(/\\/g, "\\\\")
        .replace(/"/g, '\\"')
        .replace(/\n/g, "\\n")
        .replace(/\t/g, "\\t")}"`;
}
const singleLine = (content) => ({ indentation, preindent }) => (preindent ? spaces(indentation) : "") + content;
const elmFunctionCall = (firstLine, nextLine) => ({ indentation, preindent }) => [(preindent ? spaces(indentation) : "") + firstLine,
    nextLine({ indentation: align(indentation + 4, 4), preindent: true })
].join("\n");
const defaultListOptions = {
    open: "[",
    separator: ",",
    close: "]",
};
const elmList = (elements, options = defaultListOptions) => ({ indentation, preindent }) => {
    const indent = spaces(indentation);
    if (elements.length === 0) {
        return indent + options.open + options.close;
    }
    let str = "";
    let idx = 0;
    elements.forEach(elem => {
        if (idx != 0 || preindent) {
            str += indent;
        }
        str += idx === 0 ? options.open + " " : options.separator + " ";
        str += elem({ indentation: indentation + 2, preindent: false });
        str += "\n";
        idx++;
    });
    str += indent;
    str += options.close;
    return str;
};
const tupleOptions = {
    open: "(",
    separator: ",",
    close: ")",
};
const elmTuple = (elements) => elmList(elements, tupleOptions);
const elmParen = (around) => ({ indentation, preindent }) => {
    const indent = spaces(indentation);
    return [
        (preindent ? indent : "") + "(" + around({ indentation, preindent: false }),
        indent + ")"
    ].join("\n");
};
const elmModuleHeader = (header) => {
    const imports = header.imports
        .map(i => i({ indentation: 0, preindent: false }))
        .sort()
        .join("\n");
    return `module ${header.moduleName}${elmExposing(header.exposing)({ indentation: 0, preindent: false })}
${header.moduleDocs == null ? "" : header.moduleDocs}
${imports}
`;
};
function elmExposing(exposing) {
    if (exposing == null) {
        return singleLine(" exposing (..)");
    }
    return elmFunctionCall(" exposing", elmTuple(exposing.map(singleLine)));
}
const spaces = (n) => " ".repeat(Math.max(0, n));
const align = (n, to) => Math.floor(n / to) * to;

// PUBLIC INTERFACE
function generateElmModule$2(moduleNamePrefix, blocksByClass, docs) {
    const sortedClasses = Array.from([...blocksByClass.recognized.keys(), ...blocksByClass.colorParameterized.keys()]).sort();
    const definedNames = ["globalStyles", ...sortedClasses];
    const moduleName = `${moduleNamePrefix}.Utilities`;
    return [
        elmModuleHeader({
            moduleName,
            exposing: docs.utilitiesExposing(definedNames),
            imports: [
                singleLine(`import ${moduleNamePrefix}.Theme exposing (Color)`),
                singleLine("import Tailwind.Color as Tw"),
                singleLine("import Css"),
                singleLine("import Css.Animations"),
                singleLine("import Css.Global"),
                singleLine("import Css.Media"),
            ],
            moduleDocs: docs.utilitiesModuleDocs(definedNames),
        }),
        elmUnrecognizedToFunctions(blocksByClass.unrecognized, docs),
        elmRecognizedToFunctions(blocksByClass.keyframes, blocksByClass.recognized, docs),
        elmParameterizedToFunctions(blocksByClass.keyframes, blocksByClass.colorParameterized, docs),
    ].join("");
}
// PRIVATE INTERFACE
function elmUnrecognizedToFunctions(unrecognizedBlocks, docs) {
    return `
${docs.utilitiesGlobalStyles()}
globalStyles : List Css.Global.Snippet
globalStyles =
${convertUnrecognizeds(unrecognizedBlocks)({
        indentation: 4,
        preindent: true,
    })}
`;
}
function convertUnrecognizeds(unrecognizeds) {
    return elmList(unrecognizeds.flatMap(({ selector, properties, mediaQuery }) => {
        return convertMediaQueryWrap(mediaQuery, `Css.Global.mediaQuery`, [
            elmFunctionCall(`Css.Global.selector ${elmString(selector)}`, elmList(properties.map(decl => convertBasicDeclaration("Css.property", decl.prop, decl.value))))
        ]);
    }));
}
function elmRecognizedToFunctions(keyframes, recognizedBlocksByClass, docs) {
    let body = "";
    Array.from(recognizedBlocksByClass.keys()).sort().forEach(elmClassName => {
        body = body + elmRecognizedFunction(keyframes, elmClassName, recognizedBlocksByClass.get(elmClassName), docs);
    });
    return body;
}
function elmParameterizedToFunctions(keyframes, recognizedBlocksByClass, docs) {
    let body = "";
    Array.from(recognizedBlocksByClass.keys()).sort().forEach(elmClassName => {
        body = body + elmParameterizedFunction(keyframes, elmClassName, recognizedBlocksByClass.get(elmClassName), docs);
    });
    return body;
}
function elmRecognizedFunction(keyframes, elmClassName, propertiesBlock, docs) {
    return `
${docs.utilitiesDefinition(elmClassName, propertiesBlock)}
${elmClassName} : Css.Style
${elmClassName} =
${convertDeclarationBlock(keyframes, { ...propertiesBlock, originalColorsReplaced: [] })({
        indentation: 4,
        preindent: true,
    })}
`;
}
function elmParameterizedFunction(keyframes, elmClassName, propertiesBlock, docs) {
    return `
${docs.utilitiesParameterizedDefinition(elmClassName, propertiesBlock)}
${elmClassName} : Color -> Css.Style
${elmClassName} color =
${convertDeclarationBlock(keyframes, propertiesBlock)({
        indentation: 4,
        preindent: true,
    })}
`;
}
function convertDeclaration(keyframes, declaration, cssVarNames) {
    if (cssVarNames.includes(declaration.prop)) {
        // We intentionally drop e.g. "--tw-bg-opacity" properties.
        // They'll get re-added in `Tw.propertyWithColor`, if the color doesn't have an opacity set.
        return [];
    }
    if ("valuePrefix" in declaration) {
        return [convertColorDeclaration(declaration)];
    }
    if (declaration.prop.endsWith("animation") || declaration.prop.endsWith("animation-name")) {
        const animationName = Array.from(keyframes.keys()).find(name => declaration.value.indexOf(name) >= 0);
        if (animationName == null) {
            return [convertBasicDeclaration("Css.property", declaration.prop, declaration.value)];
        }
        const strippedValue = declaration.value.replace(animationName, "").trim();
        const keyframesConverted = convertKeyframes(keyframes.get(animationName));
        if (strippedValue === "") {
            return [keyframesConverted];
        }
        return [
            singleLine(`Css.property ${elmString(declaration.prop)} ${elmString(strippedValue)}`),
            keyframesConverted
        ];
    }
    return [convertBasicDeclaration("Css.property", declaration.prop, declaration.value)];
}
function convertBasicDeclaration(functionName, property, value) {
    return singleLine(`${functionName} ${elmString(property)} ${elmString(value)}`);
}
function convertColorDeclaration(property) {
    const propertyName = elmString(property.prop);
    const valuePrefix = elmString(property.valuePrefix);
    const valueSuffix = elmString(property.valueSuffix);
    const colorExpression = property.valuePrefix === "" && property.valueSuffix === ""
        ? "c"
        : `${valuePrefix} ++ c ++ ${valueSuffix}`;
    if (property.opacity == null) {
        return singleLine(`Tw.propertyWithColor ${propertyName} (\\c -> ${colorExpression}) Nothing color`);
    }
    else if ("variableName" in property.opacity) {
        const variableName = elmString(property.opacity.variableName);
        return singleLine(`Tw.propertyWithColor ${propertyName} (\\c -> ${colorExpression}) (Just ${variableName}) color`);
    }
    else {
        const literal = elmString(property.opacity.literal);
        return elmFunctionCall(`Tw.withOpacity (Tw.Opacity ${literal}) color`, singleLine(`|> Tw.propertyWithColor ${propertyName} (\\c -> ${colorExpression}) Nothing`));
    }
}
function convertProperties(subselector, convertedProperties) {
    switch (subselector.type) {
        case "plain": return convertedProperties;
        case "pseudo": return convertPseudoProperties(subselector.rest, convertedProperties);
        case "child":
        case "descendant":
        case "adjacent":
        case "sibling":
        default: // Heh, it's better with than without it. This way we'd generate an error in subselectorFunctionFromType if something goes wrong.
            const subselectorFunction = subselectorFunctionFromType(subselector.type);
            const subselectorTransformed = elmFunctionCall(subselectorFunction, elmList([
                elmFunctionCall(`Css.Global.selector ${elmString(subselector.rest)}`, elmList(convertedProperties))
            ]));
            return [subselectorTransformed];
    }
}
function convertPseudoProperties(selectorList, convertedProperties) {
    if (selectorList.length === 0) {
        return convertedProperties;
    }
    const selector = selectorList[0];
    const functionName = pseudoselectorFunction(selector.type);
    return [
        elmFunctionCall(`${functionName} ${elmString(selector.name)}`, elmList(convertPseudoProperties(selectorList.splice(1), convertedProperties)))
    ];
}
function convertKeyframes(keyframes) {
    return elmFunctionCall("Css.animationName", elmParen(elmFunctionCall("Css.Animations.keyframes", elmList(keyframes.map(convertKeyframe)))));
}
function convertKeyframe(keyframe) {
    return elmTuple([
        singleLine(keyframe.percentage.toFixed(0)),
        elmList(keyframe.properties.map(prop => convertBasicDeclaration("Css.Animations.property", prop.prop, prop.value)))
    ]);
}
function convertMediaQueryWrap(mediaQuery, functionName, propertiesExpressions) {
    if (mediaQuery == null) {
        return propertiesExpressions;
    }
    return [
        elmFunctionCall(`${functionName} [ ${elmString(mediaQuery)} ]`, elmList(propertiesExpressions))
    ];
}
function convertDeclarationBlock(keyframes, propertiesBlock) {
    const plainProperties = findPlainProperties(propertiesBlock);
    const cssVarNames = findColorCssVarNames(plainProperties);
    const plainPropertiesCode = plainProperties.flatMap(d => convertDeclaration(keyframes, d, cssVarNames));
    const mediaQueriedPropertiesCode = propertiesBlock.propertiesBySelector.flatMap(({ subselectors, properties }) => subselectors.flatMap(subselector => {
        if (subselector.rest.type === "plain" && subselector.mediaQuery == null) {
            // We've got these covered in "plainProperties"
            return [];
        }
        const cssVarNames = findColorCssVarNames(properties);
        return convertMediaQueryWrap(subselector.mediaQuery, `Css.Media.withMediaQuery`, convertProperties(subselector.rest, properties.flatMap(d => convertDeclaration(keyframes, d, cssVarNames))));
    }));
    return batchIfNeeded(plainPropertiesCode.concat(Array.from(mediaQueriedPropertiesCode).reverse()));
}
function batchIfNeeded(expressions) {
    if (expressions.length === 1) {
        return expressions[0];
    }
    return elmFunctionCall(`Css.batch`, elmList(expressions));
}
function findPlainProperties(propertiesBlock) {
    return propertiesBlock.propertiesBySelector.flatMap(({ subselectors, properties }) => subselectors.flatMap(subselector => {
        if (subselector.rest.type === "plain" && subselector.mediaQuery == null) {
            return properties;
        }
        return [];
    }));
}
function findColorCssVarNames(properties) {
    return properties.flatMap(property => "valuePrefix" in property && property.opacity != null && "variableName" in property.opacity
        ? [property.opacity.variableName]
        : []);
}
function subselectorFunctionFromType(t) {
    switch (t) {
        case "child": return "Css.Global.children";
        case "descendant": return "Css.Global.descendants";
        case "adjacent": return "Css.Global.adjacentSiblings";
        case "sibling": return "Css.Global.generalSiblings";
        default: throw new Error("unrecognized subselector type " + t);
    }
}
function pseudoselectorFunction(t) {
    switch (t) {
        case "pseudo": return "Css.pseudoClass";
        case "pseudo-element": return "Css.pseudoElement";
        default: throw new Error("unrecognized pseudoselector type " + t);
    }
}

const namedColors = Object.entries(allCols)
    .reduce((acc, [name, col]) => Object.assign(acc, { [name]: fromNumbered(col) }), {});
// Adapted from https://github.com/tailwindlabs/tailwindcss/blob/d6121f0ede5f767029bdab9f28b141ed85d543d2/src/util/color.js
let HEX = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i;
let SHORT_HEX = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i;
let VALUE = /(?:\d+|\d*\.\d+)%?/;
let SEP = /(?:\s*,\s*|\s+)/;
let ALPHA_SEP = /\s*[,/]\s*/;
let CUSTOM_PROPERTY = /var\(--(?:[^ )]*?)\)/;
let RGB = new RegExp(`^(rgba?)\\(\\s*(${VALUE.source}|${CUSTOM_PROPERTY.source})(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${ALPHA_SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?\\s*\\)$`);
let HSL = new RegExp(`^(hsla?)\\(\\s*((?:${VALUE.source})(?:deg|rad|grad|turn)?|${CUSTOM_PROPERTY.source})(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${ALPHA_SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?\\s*\\)$`);
// In "loose" mode the color may contain fewer than 3 parts, as long as at least
// one of the parts is variable.
function parseColor(value, { loose = false } = {}) {
    if (typeof value !== 'string') {
        return null;
    }
    value = value.trim();
    if (value === 'transparent') {
        return { mode: 'rgb', color: ['0', '0', '0'], alpha: '0' };
    }
    if (value in namedColors) {
        return { mode: 'rgb', color: namedColors[value], };
    }
    let hex = value
        .replace(SHORT_HEX, (_, r, g, b, a) => ['#', r, r, g, g, b, b, a ? a + a : ''].join(''))
        .match(HEX);
    if (hex !== null) {
        return {
            mode: 'rgb',
            color: [
                parseInt(hex[1], 16).toString(),
                parseInt(hex[2], 16).toString(),
                parseInt(hex[3], 16).toString()
            ],
            alpha: hex[4] ? (parseInt(hex[4], 16) / 255).toString() : undefined,
        };
    }
    let match = value.match(RGB) ?? value.match(HSL);
    if (match === null) {
        return null;
    }
    let color = [match[2], match[3], match[4]].filter(Boolean).map((v) => v.toString());
    // rgba(var(--my-color), 0.1)
    // hsla(var(--my-color), 0.1)
    if (color.length === 2 && color[0].startsWith('var(')) {
        return {
            mode: match[1],
            color: [color[0], "", ""],
            alpha: color[1],
        };
    }
    if (!loose && color.length !== 3) {
        return null;
    }
    if (color.length < 3 && !color.some((part) => /^var\(.*?\)$/.test(part))) {
        return null;
    }
    return {
        mode: match[1],
        color: color,
        alpha: match[5]?.toString?.(),
    };
}
function colorDetectionRegex({ mode, color, alpha }) {
    return new RegExp(String.raw `${mode}\(${color.join(',?\\s')}((\s/|,)\s(:?var\((?<varname>[^)]+)\)|(?<literal>[\d.]+)))?\)`);
}
function fromNumbered(rgb) {
    return [
        rgb[0].toString(),
        rgb[1].toString(),
        rgb[2].toString(),
    ];
}

function fixClass(cls) {
    // remove the dot
    cls = cls.replace(/^(\.)/, "");
    // make other dots safe
    cls = cls.replace(/\\\./g, ".");
    // remove > anything
    cls = cls.replace(/\s?>\s?.*/, "");
    // remove pseudo-elements (::)
    cls = cls.replace(/::.*$/, "");
    // remove pseudo-classes (:)
    cls = cls.replace(/(:(active|after|before|checked|disabled|focus|focus-within|hover|visited|nth-child\((even|odd)\)|(first|last)-child))+$/, "");
    // make / safe for elm
    cls = cls.replace(/\\\//g, "/");
    // make \/ safe for elm
    cls = cls.replace(/\\([/])/g, "\\\\$1");
    // make \: safe for elm
    cls = cls.replace(/\\([:])/g, "$1");
    return cls;
}
function toElmName(cls) {
    var elm = cls;
    // This is faster than a general solution
    elm = elm.replace(/^2(x[ls].*$)/, "x$1");
    elm = elm.replace(/^3(x[ls].*$)/, "xx$1");
    elm = elm.replace(/^4(x[ls].*$)/, "xxx$1");
    elm = elm.replace(/^5(x[ls].*$)/, "xxxx$1");
    // handle negative at start of string
    elm = elm.replace(/^-([a-z])/, "_neg_$1");
    // handle negative with variant
    elm = elm.replace(/:-([a-z])/, "__neg_$1");
    // replace dashes now we have sorted the negative stuff
    elm = elm.replace(/-/g, "_");
    // replace :
    elm = elm.replace(/:/g, "__");
    // replace %
    elm = elm.replace(/%/g, "pct");
    // handle fractions
    elm = elm.replace(/\//g, "over");
    // clean up
    elm = elm.replace(/\\__/g, "_");
    elm = elm.replace(/^_/g, "");
    // handle :nth-child(even), etc
    elm = elm.replace(/_nth_child\(.+\)/, "");
    elm = elm.replace(/_(last|first)_child/, "");
    // replace any other dots
    elm = elm.replace(/\./g, "_dot_");
    return elm;
}

const noDocumentationGenerator = {
    utilitiesExposing: _definedNames => null,
    utilitiesModuleDocs: _definedNames => null,
    utilitiesGlobalStyles: () => "",
    utilitiesDefinition: (_name, _declaration) => "",
    utilitiesParameterizedDefinition: (_name, _declaration) => "",
    breakpointsExposing: _definedNames => null,
    breakpointsModuleDocs: _definedNames => null,
    breakpointsDefinition: (_breakpoint) => "",
    themeColorDefinition: (_name, _value) => "",
    themeOpacityDefinition: (_name, _value) => "",
};
const defaultDocumentationGenerator = {
    utilitiesExposing: definedNames => definedNames,
    utilitiesModuleDocs: definedNames => `
{-|


## Tailwind Utilities

This module contains

1.  Tailwind's style reset in the \`globalStyles\` definition.
    Make sure to include this in your HTML via elm-css' \`Css.Global.global\` function.
2.  All default tailwind css utility classes. You can browse the documentation on
    [tailwind's website](https://tailwindcss.com/docs)

${definedNames.map(c => `@docs ${c}`).join("\n")}

-}
`,
    utilitiesGlobalStyles: () => `
{-| This contains tailwind's style reset.

This is something similar to normalize.css, if you're familiar with it.

You **need to include this in your html** at any time you use this module,
as some of the classes in here depend on css variables defined in the global styles.

You include it like so:

    import Css.Global
    import Html.Styled as Html exposing (Html)
    import Tailwind.Utilities exposing (globalStyles)

    view : Html msg
    view =
        div []
            [ -- Like this:
              Css.Global.global globalStyles

            -- Continue with any other Html
            ]

It only needs to be included once.

-}`,
    utilitiesDefinition: (_name, declaration) => `
{-| ${declaration.originalRules.length > 1
        ? "This class combines the effects of following css declarations:"
        : "This class has the effect of following css declaration:"}

\`\`\`css
${declaration.originalRules.map(rule => rule.toString()).join("\n\n")}
\`\`\`

Make sure to check out the [tailwind documentation](https://tailwindcss.com/docs)!

-}`,
    utilitiesParameterizedDefinition: (_name, declaration) => `
{-| This class has effects of css declarations similar to the following:

\`\`\`css
${replaceOriginalColorsWithPlaceholder(declaration.originalRules.map(rule => rule.toString()).join("\n\n"), declaration.originalColorsReplaced)}
\`\`\`

The \`<color>\` can be chosen with the first parameter.

Make sure to check out the [tailwind documentation](https://tailwindcss.com/docs)!

-}`,
    breakpointsExposing: definedNames => definedNames,
    breakpointsModuleDocs: definedNames => `
{-|


## Tailwind Breakpoints


### How tailwind's breakpoints work

Tailwind (by default) uses min-width breakpoints.

The workflow with them should be like this:

1.  You define styles for mobile without breakpoints
2.  You adjust the styling for devices _bigger than_ the \`sm\` (or \`lg\`, etc.) breakpoint
3.  You in turn override these styles with even higher breakpoints

Read more about breakpoints in the [tailwind documentation].


### A note about breakpoint usage oder

The above relies on style definitions having a certain order in css. The first style in css wins.

Thus, unfortunately **you need to be careful about the order you use your breakpoints** in elm-css.
Make sure to use breakpoints from big to small, like so:

    myElement =
        div
            [ css
                [ xxl [ text_indigo_700 ]
                , lg [ text_blue_700 ]
                , sm [ text_green_700 ]
                ]
            ]
            [ text "Colorful text"
            ]

This is _not_ the case when using tailwind directly, because then tailwind has control over the
order of declarations in the generated css, which we don't have.


### Breakpoints

${definedNames.map(name => `@docs ${name}`).join("\n")}

[tailwind documentation]: https://tailwindcss.com/docs/responsive-design

-}
`,
    breakpointsDefinition: ({ name, size }) => `
{-| Media query breakpoint for minimum width ${size}

CSS: \`@media (min-width: ${size}) { ... }\`

Also see the [tailwind documentation](https://tailwindcss.com/docs/responsive-design)

-}`,
    themeColorDefinition: (name, value) => `
{-| The color \`${name}\` from the tailwind configuration.

Its value is \`${value}\`.

Also see the [tailwind documentation](https://tailwindcss.com/docs/responsive-design)

-}`,
    themeOpacityDefinition: (name, value) => `
{-| The opacity \`${name}\` from the tailwind configuration.

It is set to \`${value}\` (likely a number between 0 and 1, where 1 means opaque and 0 means transparent)

Also see the [tailwind documentation](https://tailwindcss.com/docs/responsive-design)

-}`,
};
const themeModuleDocumentation = (definedColors, definedOpacities) => `
{-|


## This Tailwind Theme

This module contains all colors and opacities from your tailwind configuration.

If you want to extend the set of available colors or opacities, take a look [configuring tailwind].


### Colors

@docs Color
${definedColors.map(name => `@docs ${name}`).join("\n")}


### Opacities

@docs Opacity
${definedOpacities.map(name => `@docs ${name}`).join("\n")}

[configuring tailwind]: https://tailwindcss.com/docs/responsive-design

-}
`;
function replaceOriginalColorsWithPlaceholder(rule, originalColorsReplaced) {
    for (const replacedColor of originalColorsReplaced) {
        rule = rule.replace(replacedColor, "<color>");
    }
    return rule;
}

var documentation = /*#__PURE__*/Object.freeze({
    __proto__: null,
    noDocumentationGenerator: noDocumentationGenerator,
    defaultDocumentationGenerator: defaultDocumentationGenerator,
    themeModuleDocumentation: themeModuleDocumentation
});

function generateElmModule$1(moduleNamePrefix, expandedColors, expandedOpacities, docs) {
    const definedColors = expandedColors.map((([color, _]) => color));
    const definedOpacities = Object.keys(expandedOpacities);
    const moduleName = `${moduleNamePrefix}.Theme`;
    return [
        elmModuleHeader({
            moduleName,
            exposing: [
                "Color",
                ...definedColors,
                "Opacity",
                ...definedOpacities,
            ],
            imports: [
                singleLine("import Tailwind.Color as Tw"),
            ],
            moduleDocs: themeModuleDocumentation(definedColors, definedOpacities),
        }),
        types(),
        generateColors(expandedColors, docs),
        generateOpacities(expandedOpacities, docs),
    ].join("");
}
function types() {
    return `

{-| The type for tailwind colors.

Values of this type can be found in this module.

They can be used with tailwind utility functions like \`bg_color\`.

If you want to generate custom values, install the [elm-tailwind-modules-base](https://package.elm-lang.org/packages/matheus23/elm-tailwind-modules-base/latest/)
library and its utilities like \`arbitraryRgb\`.

-}
type alias Color =
    Tw.Color


{-| The type for tailwind opacities.

Values of this type can be found in this module.

They can be used to modify the default opacities associated with colors
using the \`withOpacity\` function.

If you want to generate custom values, install the [elm-tailwind-modules-base](https://package.elm-lang.org/packages/matheus23/elm-tailwind-modules-base/latest/)
library and its utilities like \`arbitraryOpactiyPct\`.

-}
type alias Opacity =
    Tw.Opacity
`;
}
function generateColors(expandedColors, docs) {
    return expandedColors.map(([colorName, colorValue]) => {
        const elmValue = (() => {
            const parsedColor = parseColor(colorValue);
            if (parsedColor == null) {
                return `Tw.Keyword "${colorValue}"`;
            }
            const [r, g, b] = parsedColor.color;
            let opacity = "Tw.ViaVariable";
            if (parsedColor.alpha != null) {
                opacity = `(Tw.Opacity "${parsedColor.alpha}")`;
            }
            return `Tw.Color "${parsedColor.mode}" "${r}" "${g}" "${b}" ${opacity}`;
        })();
        return `
${docs.themeColorDefinition(colorName, colorValue)}
${colorName} : Color
${colorName} =
    ${elmValue}
`;
    }).join("");
}
function generateOpacities(opacities, docs) {
    return Object.entries(opacities).map(([opacityName, opacityValue]) => {
        return `
${docs.themeOpacityDefinition(opacityName, opacityValue)}
${opacityName} : Opacity
${opacityName} =
    Tw.Opacity "${opacityValue}"
`;
    }).join("");
}
function expandColors(keysSoFar, colors) {
    return Object.entries(colors).flatMap(([key, value]) => {
        if (typeof value === 'string') {
            const finalKey = key === "DEFAULT" ? [] : [key];
            return [[toElmName([...keysSoFar, ...finalKey].join('_')), value]];
        }
        else {
            return expandColors([key, ...keysSoFar], value);
        }
    });
}
function expandOpacities(opacities) {
    const expanded = {};
    for (const [suffix, value] of Object.entries(opacities)) {
        expanded[`opacity${suffix}`] = value;
    }
    return expanded;
}

function generateElmModule(moduleNamePrefix, resolvedConfig, docs) {
    const moduleName = `${moduleNamePrefix}.Breakpoints`;
    const breakpoints = Object
        .entries(resolvedConfig.theme.screens)
        .map(([screen, size]) => convertConfigToBreakpoint(screen, size))
        .sort((a, b) => a.name < b.name ? -1 : 1);
    return [
        elmHeader(moduleName, breakpoints.map(b => b.name), docs),
        breakpoints.map(b => elmBreakpointFunction(b, docs)).join(""),
    ].join("");
}
function elmHeader(moduleName, definitions, docs) {
    return elmModuleHeader({
        moduleName,
        exposing: docs.breakpointsExposing(definitions),
        moduleDocs: docs.breakpointsModuleDocs(definitions),
        imports: [
            singleLine("import Css"),
            singleLine("import Css.Media"),
        ],
    });
}
// Full breakpointSize reference: https://tailwindcss.com/docs/breakpoints
function convertConfigToBreakpoint(screen, size) {
    return {
        name: toElmName(screen),
        size: size,
    };
}
function elmBreakpointFunction({ name, size }, docs) {
    return `
${docs.breakpointsDefinition({ name, size })}
${name} : List Css.Style -> Css.Style
${name} =
    Css.Media.withMediaQuery [ "(min-width: ${size})" ]
`;
}

//
function isBasicSubselectorType(type) {
    return ["child", "descendant", "adjacent", "sibling"].some(basic => basic === type);
}
function isPseudoSelector(selector) {
    return selector.type === "pseudo";
}
function isPseudoElementSelector(selector) {
    return selector.type === "pseudo-element";
}

const cssWhatErrors = [
    "Unmatched selector: ",
    "Expected name, found ",
    "Empty sub-selector",
    "Malformed attribute selector: ",
    "Unmatched quotes in :",
    "Missing closing parenthesis in :",
    "Parenthesis not matched",
    "Empty sub-selector",
];
function groupDeclarationBlocksByClass(postCssRoot, resolvedColors, logFunction) {
    const recognized = new Map();
    const colorParameterized = new Map();
    const unrecognized = [];
    const keyframes = new Map();
    const defaultRecognized = (originalClassName) => ({
        propertiesBySelector: [],
        originalRules: [],
        originalClassName,
    });
    postCssRoot.each(child => {
        switch (child.type) {
            case "comment":
                // We don't care about comments
                return;
            case "decl":
                logFunction("Encountered declaration immediately below the postcss root. This shouldn't happen. Ignoring " + child.toString());
                return;
            case "atrule":
                if (child.name === "media") {
                    const mediaQuery = child.params;
                    child.walkRules(rule => handleRule(mediaQuery, rule));
                    return;
                }
                if (child.name === "keyframes") {
                    const animationName = child.params;
                    let keyframeFrames = [];
                    child.walkRules(rule => {
                        try {
                            keyframeFrames.push({
                                percentage: parseKeyframePercentage(rule.selector),
                                properties: collectProperties(rule),
                            });
                        }
                        catch (e) {
                            if (e.message.startsWith("Couldn't parse")) {
                                logFunction(e.message);
                                return;
                            }
                            throw e;
                        }
                    });
                    keyframes.set(animationName, keyframeFrames);
                    // We don't need the keyframe to be there in the global styles anymore, it will automatically get inserted by elm-css
                    child.remove();
                    return;
                }
                if (child.name.endsWith("keyframes")) {
                    // We already cover cases like @-webkit-keyframes with the code above.
                    return;
                }
                logFunction("Encountered unknown @-rule: " + child.name);
                return;
            case "rule":
                handleRule(null, child);
                return;
        }
    });
    function handleRule(mediaQuery, rule) {
        // parse the selectors
        let selectors;
        try {
            selectors = CssWhat.parse(rule.selector);
        }
        catch (e) {
            if (cssWhatErrors.some(msg => e.message.startsWith(msg))) {
                unrecognized.push({
                    selector: rule.selector,
                    properties: collectProperties(rule),
                    mediaQuery: mediaQuery,
                });
                return;
            }
            throw e;
        }
        // Ensure we understand all individual selectors
        // If not, we'll try to put them into globalStyles
        const parts = selectors.map(stripClassSelector);
        try {
            parts.forEach(part => {
                if (part.class == null) {
                    throw "Has unrecognized";
                }
            });
        }
        catch (e) {
            if (e === "Has unrecognized") {
                unrecognized.push({
                    selector: rule.selector,
                    properties: collectProperties(rule),
                    mediaQuery: mediaQuery,
                });
                return;
            }
            throw e;
        }
        // Ensure we support all the subselector types
        let subselectors;
        try {
            subselectors = parts.map(part => ({
                mediaQuery,
                rest: recognizeSelectorRest(part.rest),
            }));
        }
        catch (e) {
            if (e.message.startsWith("Unsupported type")) {
                unrecognized.push({
                    selector: rule.selector,
                    properties: collectProperties(rule),
                    mediaQuery: mediaQuery,
                });
                return;
            }
            throw e;
        }
        parts.forEach((part, index) => {
            // create a valid elm identifier from the classname
            const elmDeclName = toElmName(fixClass(part.class));
            const subselector = subselectors[index];
            // concat properties to possibly existing property lists
            const item = recognized.get(elmDeclName) || defaultRecognized(part.class);
            recognized.set(elmDeclName, {
                propertiesBySelector: addToSelectorList(item.propertiesBySelector, [subselector], collectProperties(rule)),
                originalRules: [
                    ...item.originalRules,
                    mediaQuery == null ? rule : rule.parent,
                ],
                originalClassName: part.class,
            });
        });
        // We can now remove the rule. It's included in the elm code.
        // The css generated by postcss will only include whatever can't be expressed in
        // elm in a better way (e.g. global styles or global styles which aren't supported
        // in elm-css, yet; for example @font-face rules).
        rule.remove();
    }
    const colorInfo = parameterizationInfo(resolvedColors);
    for (const [elmDeclName, declaration] of recognized) {
        const parameterizedDeclaration = isParameterizable(elmDeclName, declaration, colorInfo);
        if (parameterizedDeclaration === false) {
            continue;
        }
        recognized.delete(elmDeclName);
        if (parameterizedDeclaration === null) {
            continue;
        }
        const [name, value] = parameterizedDeclaration;
        colorParameterized.set(name, value);
    }
    return { recognized, colorParameterized, unrecognized, keyframes };
}
function addToSelectorList(propertiesBySelector, subselectors, properties) {
    let result = Array.from(propertiesBySelector);
    const index = result.findIndex(elem => deepEqual(elem.subselectors, subselectors));
    if (index >= 0) {
        result[index] = {
            subselectors: subselectors,
            properties: result[index].properties.concat(properties),
        };
        return result;
    }
    result.push({
        subselectors,
        properties,
    });
    return result;
}
function everyPartIsSupportedPseudo(selector) {
    return selector.every(part => isPseudoSelector(part) || isPseudoElementSelector(part));
}
function recognizeSelectorRest(selector) {
    if (selector.length === 0) {
        return { type: "plain" };
    }
    const type = selector[0].type;
    const rest = CssWhat.stringify([selector.slice(1)]);
    if (isBasicSubselectorType(type)) {
        return { type, rest };
    }
    if (everyPartIsSupportedPseudo(selector)) {
        return {
            type: "pseudo",
            rest: selector.map(part => ({ type: part.type, name: part.name }))
        };
    }
    throw new Error(`Unsupported type: ${type}`);
}
function collectProperties(rule) {
    let properties = [];
    rule.walkDecls(declaration => {
        properties.push({
            prop: declaration.prop,
            value: declaration.value,
        });
    });
    return properties;
}
function parseKeyframePercentage(selector) {
    const trimmed = selector.trim();
    if (trimmed === "from") {
        return 0;
    }
    if (trimmed === "to") {
        return 100;
    }
    if (trimmed.endsWith("%")) {
        const numberPart = trimmed.substring(0, trimmed.length - 1);
        try {
            return parseInt(numberPart);
        }
        catch (e) {
            throw "Couldn't parse keyframe percentage: " + numberPart;
        }
    }
    throw "Couldn't parse keyframe percentage indicator: " + selector;
}
function stripClassSelector(selectorPart) {
    if (selectorPart.length === 0) {
        return { class: null, rest: [] };
    }
    const first = selectorPart[0];
    const rest = selectorPart.slice(1);
    if (!(first.type === "attribute" && first.name === "class")) {
        return { class: null, rest: selectorPart };
    }
    return {
        class: first.value,
        rest,
    };
}
function parameterizationInfo(resolvedColors) {
    // If we don't sort by descending color name length, we have this edge-case:
    // e.g. blue_50 & blue_500 both appear in the regex.
    // bg_blue_500 matches with blue_50, but we want to match blue_500,
    // so we need the longest possible match
    const possibleColorNames = resolvedColors.map(([name, _]) => name).sort((a, b) => b.length - a.length);
    const anyColorName = new RegExp(String.raw `(:?.*)(?<colorName>${possibleColorNames.join('|')}).*$`);
    const colorByName = resolvedColors.reduce((acc, [name, original]) => {
        const parsed = parseColor(original);
        const regex = parsed != null ? colorDetectionRegex(parsed) : null;
        const info = {
            original,
            parsed,
            regex,
        };
        return Object.assign(acc, { [name]: info });
    }, {});
    return {
        resolvedColors,
        anyColorName,
        colorByName,
    };
}
function isParameterizable(declarationName, declaration, colorInfo) {
    const matches = declarationName.match(colorInfo.anyColorName);
    const colorName = matches?.groups?.colorName;
    if (colorName == null) {
        return false;
    }
    // We don't want to parameterize the opacity-variants of declarations.
    // We test this by capturing the regex part after the color name and seeing
    // if it included the "/" part, which is translated into an "over" str in toElmName.
    const afterColorNamePart = declarationName.substring(colorName.length + declarationName.lastIndexOf(colorName));
    if (afterColorNamePart.includes("over")) {
        return null;
    }
    const resolvedColor = colorInfo.colorByName[colorName];
    if (resolvedColor == null) {
        console.warn("Couldn't find a color with this name", colorName);
    }
    const originalColorsReplaced = [];
    const parameterizedDeclaration = {
        ...declaration,
        propertiesBySelector: declaration.propertiesBySelector.map(selector => ({
            ...selector,
            properties: selector.properties.map(property => {
                // Look for unmodified colors appearing as in the config
                const matchIndex = property.value.indexOf(resolvedColor.original);
                if (matchIndex >= 0) {
                    const matchStartIdx = matchIndex;
                    const matchEndIdx = matchIndex + resolvedColor.original.length;
                    const valuePrefix = property.value.substring(0, matchStartIdx);
                    const valueSuffix = property.value.substring(matchEndIdx);
                    originalColorsReplaced.push(resolvedColor.original);
                    return {
                        prop: property.prop,
                        valuePrefix,
                        valueSuffix,
                    };
                }
                // Look for modified colors via regex
                if (resolvedColor.regex != null) {
                    const matchParsed = property.value.match(resolvedColor.regex);
                    if (matchParsed) {
                        const matchStartIdx = matchParsed.index;
                        const matchEndIdx = matchParsed.index + matchParsed[0].length;
                        const valuePrefix = property.value.substring(0, matchStartIdx);
                        const valueSuffix = property.value.substring(matchEndIdx);
                        const opacity = matchParsed?.groups?.varname != null
                            ? { variableName: matchParsed.groups.varname }
                            : matchParsed?.groups?.literal != null
                                ? { literal: matchParsed.groups.literal }
                                : undefined;
                        originalColorsReplaced.push(matchParsed[0]);
                        return {
                            prop: property.prop,
                            valuePrefix,
                            valueSuffix,
                            opacity,
                        };
                    }
                }
                return property;
            })
        }))
    };
    if (originalColorsReplaced.length === 0) {
        return false;
    }
    return [`${matches[1]}color`, { ...parameterizedDeclaration, originalColorsReplaced }];
}

const defaultTailwindConfig = {
    content: ["intentionally.empty"],
    variants: [],
    safelist: [{ pattern: /.*/, variants: [] }]
};
const docs = documentation;
/**
 * Runs elm-tailwind-modules like the command line interface is run.
 *
 * @param directory
 * the directory path to save to. If null, this function won't save the generated files to disk.
 *
 * @returns
 * the generated modules as string.
 */
async function run({ directory = "./src", moduleName = "Tailwind", postcssPlugins = [], tailwindConfig = defaultTailwindConfig, generateDocumentation = false, logFunction = console.log, }) {
    const tailwindConfig_ = {
        ...tailwindConfig,
        safelist: tailwindConfig.safelist || [
            { pattern: /.*/, variants: [] }
        ],
        content: tailwindConfig.content || ["intentionally.empty"],
    };
    let themeModule;
    let utilitiesModule;
    let breakpointsModule;
    const afterTailwindPlugin = asPostcssPlugin({
        moduleName,
        tailwindConfig: tailwindConfig_,
        generateDocumentation,
        logFunction,
        modulesGeneratedHook: async (generated) => {
            themeModule = generated.themeModule;
            utilitiesModule = generated.utilitiesModule;
            breakpointsModule = generated.breakpointsModule;
            if (directory != null) {
                await writeGeneratedFiles({ directory, moduleName, logFunction, generated });
            }
        }
    });
    const from = "generated in-memory";
    const css = "@tailwind base;\n@tailwind components;\n@tailwind utilities;";
    const to = "output in-memory";
    const postcssResult = await postcss.default([
        tailwindcss(tailwindConfig_),
        ...postcssPlugins,
        afterTailwindPlugin
    ]).process(css, { from, to });
    return { themeModule, utilitiesModule, breakpointsModule, postcssResult };
}
/**
 * This exposes the actual postcss plugin that's used in `run`.
 *
 * @param modulesGeneratedHook
 * a callback which is called once the modules have been generated.
 */
function asPostcssPlugin({ moduleName, tailwindConfig, generateDocumentation, logFunction, modulesGeneratedHook }) {
    validateModuleName(moduleName);
    warningsTailwindConfig(tailwindConfig, logFunction);
    return {
        postcssPlugin: "elm-tailwind-modules",
        async OnceExit(root) {
            const docGen = resolveDocGen(generateDocumentation);
            const resolvedConfig = resolveConfig(tailwindConfig);
            const resolvedColors = expandColors([], resolvedConfig.theme.colors);
            const resolvedOpacities = expandOpacities(resolvedConfig.theme.opacity);
            const blocksByClass = groupDeclarationBlocksByClass(root, resolvedColors, logFunction);
            const utilitiesModule = generateElmModule$2(moduleName, blocksByClass, docGen);
            const themeModule = generateElmModule$1(moduleName, resolvedColors, resolvedOpacities, docGen);
            const breakpointsModule = generateElmModule(moduleName, resolvedConfig, docGen);
            modulesGeneratedHook({ utilitiesModule, breakpointsModule, themeModule });
        }
    };
}
/**
 * This exposes the actual logic for writing files and writing some console output
 * that is used in `run` (in the callback to `asPostcssPlugin`).
 */
async function writeGeneratedFiles({ directory, moduleName, logFunction, generated }) {
    const modulePath = path.join.apply(null, moduleName.split("."));
    logFunction([
        "Saved",
        " - " + chalk.blue(await writeFile(path.resolve(directory, `${modulePath}/Utilities.elm`), generated.utilitiesModule)),
        " - " + chalk.blue(await writeFile(path.resolve(directory, `${modulePath}/Theme.elm`), generated.themeModule)),
        " - " + chalk.blue(await writeFile(path.resolve(directory, `${modulePath}/Breakpoints.elm`), generated.breakpointsModule)),
    ].join("\n"));
}
/*
 * Helpers
 */
function validateModuleName(moduleName) {
    const validModuleName = /^[0-9A-Za-z]([A-Za-z0-9.]*[0-9a-zA-Z])?$/;
    if (!moduleName.match(validModuleName)) {
        throw `The module name prefix "${moduleName}" doesn't appear to be valid. It should be something like "Tailwind" or "Gen.Css"`;
    }
}
function warningsTailwindConfig(tailwindConfig, logFunction) {
    if (!(isEmpty(tailwindConfig.variants) && isArray(tailwindConfig.variants))) {
        logFunction(`${chalk.bold.yellow("Warning:")} It is recommended to ${chalk.bold(`set ${chalk.green("`variants: []`")} in the tailwindConfig`)}, otherwise the generated files are huge.
Instead, you should use elm-css functions like ${chalk.blue("Css.focus")} and ${chalk.blue("Css.hover")}.
If you still have a usecase that needs variants, please create an issue.`);
    }
}
function resolveDocGen(docs) {
    if (docs === true) {
        return defaultDocumentationGenerator;
    }
    if (docs === false) {
        return noDocumentationGenerator;
    }
    return docs;
}
/**
 * Async helper to write given file to disk
 */
async function writeFile(fname, content) {
    const folder = path.dirname(fname);
    await promises.mkdir(folder, { recursive: true });
    await promises.writeFile(fname, content);
    return path.relative(".", fname);
}

export { asPostcssPlugin, defaultTailwindConfig, docs, run, writeGeneratedFiles };
